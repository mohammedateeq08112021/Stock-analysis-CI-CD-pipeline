# -*- coding: utf-8 -*-
"""Financial Advisory System for Risk and Return Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yCJPIbjQxy8ZsX48q_PdHxTW-NwuSRwa

# **Financial Advisory System**

This notebook builds the foundation of a Financial Advisory System using a dataset of global stock prices. It covers the first four stages of the CRISP-DM methodology:


*  Business Understanding
*  Data Understanding
*  Data Preparation
*  Data Visualization

# Business Understanding
Investors today face overwhelming amounts of financial data and uncertainty. Our goal is to create a data-driven advisory system that simplifies this complexity by identifying promising stocks based on trends and historical performance.

**Stakeholders:** Retail Investors, Mutual Fund Managers, Financial Analysts

**Goal:** Support decision-making using stock analytics

**Success Criteria:** Actionable insights, strong visualizations, clean data for modeling

# Data Understanding
We begin by loading and exploring the provided World Stock Prices Dataset, which contains historical financial data of global companies. This dataset includes standard stock market variables such as Open, High, Low, Close prices, Volume, as well as meta-information like Ticker, Brand Name, Industry, and Country. This prepares the dataset for clean, meaningful analysis.

We start by importing essential Python libraries:

numpy and pandas for numerical and data manipulation,

matplotlib.pyplot and seaborn for data visualization,

datetime for handling date and time operations.

---
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
import plotly.express as px
import plotly.express as px

"""We load the dataset using pandas.read_csv(), which reads the stock price data from a CSV file into a DataFrame."""

df = pd.read_csv("/content/World-Stock-Prices-Dataset.csv")

df

"""We use df.describe() to generate summary statistics for the numerical columns in the dataset."""

df.describe()

"""df.info() provides a concise summary of the dataset, including the number of entries, column names, data types, and non-null counts."""

df.info()

"""We use df.isnull().sum() to calculate the total number of missing values in each column."""

missing_values = df.isnull().sum()

missing_values

"""We convert the Date column to proper datetime format using pd.to_datetime(), handling invalid entries with errors='coerce'. Then, we format the dates into a standard "YYYY-MM-DD" string format for consistency in time-series analysis and plotting."""

df['Date'] = pd.to_datetime(df['Date'], errors='coerce') # Convert to datetime objects
df['Date'] = df['Date'].dt.strftime("%Y-%m-%d")

"""df.head() displays the first five rows of the dataset, allowing us to quickly preview the structure, data format, and sample values after initial preprocessing steps."""

df.head()

"""We save the cleaned and formatted dataset to a new CSV file named "Cleaned_Stock_Data.csv" using to_csv()"""

df.to_csv("Cleaned_Stock_Data.csv", index=False)

"""We use df.head() again to confirm that the dataset has been properly cleaned and saved."""

df.head()

"""We refine our dataset by focusing on well-established companies:


*  The Date column is reconverted to datetime format (in case of previous format loss).
*  We identify the earliest record for each company using groupby and min().
*   Companies that have been trading since at least 2015 are selected to ensure data consistency over time.
*   The main DataFrame is filtered to include only these long-standing companies, creating a more reliable subset for analysis.
*  Finally, we export this filtered dataset as "Filtered_Stock_Data.csv" for future use.
"""

# Convert 'Date' column to datetime format
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')

# Find the earliest record for each company
company_first_dates = df.groupby("Brand_Name")["Date"].min()

# Filter companies that have existed since at least 2015
existing_companies = company_first_dates[company_first_dates <= "2015-01-01"].index

# Filter the main dataframe to keep only those companies
filtered_df = df[df["Brand_Name"].isin(existing_companies)]

# Save the filtered data if needed
filtered_df.to_csv("Filtered_Stock_Data.csv", index=False)

df.head()

"""We print the first few rows of the filtered_df DataFrame to verify that the filtering operation was successful and that only companies with data going back to 2015 are included."""

print(filtered_df.head())

df

"""We filter the dataset to include only records from 2015 onwards, focusing on recent market trends. The result is saved as "Stock_Data_After_2015.csv"."""

# Keep only records from 2015 onwards
df_filtered = df[df['Date'] >= "2015-01-01"]

# Save the cleaned dataset if needed
df_filtered.to_csv("Stock_Data_After_2015.csv", index=False)

print(df_filtered.head())

df.to_csv("Filtered_Stock_Data.csv", index=False)

df = pd.read_csv("Stock_Data_After_2015.csv")

df.head()

df.describe()

df.info()

missing_values = df.isnull().sum()

missing_values

"""We identify the top 5 companies that have paid the highest total dividends by grouping the data by Brand_Name and summing the Dividends column.


"""

top_dividend_companies = df.groupby("Brand_Name")["Dividends"].sum().nlargest(5)

top_dividend_companies

"""We remove unnecessary columns (Stock Splits, Ticker, Capital Gains) from the dataset to streamline the analysis and reduce noise."""

sdf = df.drop(columns=['Stock Splits', 'Ticker', 'Capital Gains'], errors='ignore')

df

"""# Industry-Wise Trade Volume
This plot highlights which industries have the highest trading activity based on total volume. It helps investors identify the most liquid and actively traded sectors. From the chart, we observe that industries like technology and finance dominate in trade volume, indicating strong investor interest and high market activity in these sectors.
"""

# Group the data by Industry_Tag and sum the Volume
industry_volume = df.groupby('Industry_Tag')['Volume'].sum()

# Create the plot
plt.figure(figsize=(10, 6))  # Optional: adjust figure size for better visibility
plt.plot(industry_volume.index, industry_volume.values)
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.xlabel('Industry')
plt.ylabel('Total Volume in 100 Billion')
plt.title('Volume by Industry')
plt.tight_layout()  # Adjust layout to prevent label cutoff
plt.show()

# Alternative: For a bar plot which might be more suitable for categorical data
# plt.bar(industry_volume.index, industry_volume.values)

"""# Ticker-Wise Trade Volume
This bar chart shows the total trading volume for each company (ticker), helping investors understand which individual stocks are most actively traded. Higher volume often indicates greater investor interest and liquidity. From the result, we can see that companies like Apple, Nvidia and Tesla have significantly higher trade volumes, making them potential candidates for active investors.
"""

# Calculate the volume for each ticker
Ticker_Volume = df.groupby('Ticker')['Volume'].sum() # This line calculates and assigns the volume to Ticker_Volume

plt.figure(figsize = (10,6))
plt.bar(Ticker_Volume.index,Ticker_Volume.values)

plt.title("Histogram")
plt.xlabel("Ticker")
plt.ylabel("volume")
plt.xticks(rotation = 90)
plt.tight_layout()

plt.show()

"""# Closing Price Trends of Top 10 Brands
This interactive line chart shows how the closing stock prices of the top 10 companies have changed over time. It helps investors visually compare long-term performance and identify consistent growth or volatility.
"""

import plotly.graph_objs as go


# Ensure date is in datetime format
df['Date'] = pd.to_datetime(df['Date'])

# Get top 5 companies by number of records
top_10 = df['Brand_Name'].value_counts().head(10).index

# Filter to only those companies
filtered_df = df[df['Brand_Name'].isin(top_10)].copy()

# Sort by date for proper line plotting
filtered_df = filtered_df.sort_values(['Brand_Name', 'Date'])

# Create figure
fig = go.Figure()

# Add a line for each company
for company in top_10:
    company_data = filtered_df[filtered_df['Brand_Name'] == company]
    fig.add_trace(go.Scatter(
        x=company_data['Date'],
        y=company_data['Close'],
        mode='lines',
        name=company,
        opacity=0.8
    ))

# Layout styling
fig.update_layout(
    title="Stock Price Trends of Top 10 Brands",
    xaxis_title="Date",
    yaxis_title="Closing Price ($)",
    xaxis=dict(tickangle=45),
    legend=dict(
        x=1.05, y=1, traceorder='normal',
        font=dict(size=10),
        orientation='v'
    ),
    margin=dict(l=0, r=0, t=40, b=0),
    hovermode='x',
    template='plotly_dark'
)

fig.show()

"""# Cumulative Returns of Top Companies
This line plot shows how much an investment would have grown in each of the top 5 companies over time. It helps investors identify which stocks have delivered the best long-term returns.
"""

# Step 1: Ensure Date is datetime and sorted
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df.sort_values(['Brand_Name', 'Date'], inplace=True)

# Step 2: Calculate daily returns & cumulative return
df['Returns'] = df.groupby('Brand_Name')['Close'].pct_change()
df['Cumulative Return'] = df.groupby('Brand_Name')['Returns'].transform(lambda x: (1 + x).cumprod())

# Step 3: Select Top 5-10 Companies by frequency
top_companies = df['Brand_Name'].value_counts().head(5).index.tolist()
df_top = df[df['Brand_Name'].isin(top_companies)]

# Step 4: Plot cumulative returns
plt.figure(figsize=(12, 6))
for company in top_companies:
    company_data = df_top[df_top['Brand_Name'] == company]
    plt.plot(company_data['Date'], company_data['Cumulative Return'], label=company)

# Step 5: Styling
plt.title(" Cumulative Returns of Top Companies Over Time", fontsize=14)
plt.xlabel("Date")
plt.ylabel("Cumulative Return")
plt.legend(title="Company", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.grid(True)
plt.show()

"""# Volatility of Companies Based on Closing Price
This horizontal bar chart displays how much each company's stock price fluctuates, measured by standard deviation. Higher volatility indicates greater risk, helping investors identify which stocks are more stable or unpredictable.
"""

# Calculate the volatility (standard deviation of closing prices) for each company
volatility_df = df.groupby('Ticker')['Close'].std().reset_index()
volatility_df.columns = ['Company', 'Volatility']  # Rename columns for clarity

# Set height based on number of companies (40 pixels per company)
plt.figure(figsize=(10, len(volatility_df) * 0.4))
plt.barh(volatility_df['Company'], volatility_df['Volatility'], color='teal')
plt.title('Volatility of Companies Based on Closing Price')
plt.xlabel('Volatility (Standard Deviation)')
plt.ylabel('Company (Ticker)')
plt.tight_layout()
plt.show()

"""# Top 5 Most Volatile Companies
This bar chart highlights the five companies with the highest stock price fluctuations. These are considered higher-risk investments, useful for short-term traders or high-risk, high-reward strategies.
"""

# Calculate volatility
volatility_df = df.groupby('Ticker')['Close'].std().reset_index()
volatility_df.columns = ['Ticker', 'Volatility']

# Top 5 most volatile
top_5_volatile = volatility_df.sort_values(by='Volatility', ascending=False).head(5)

# Plot
plt.figure(figsize=(8, 5))
sns.barplot(data=top_5_volatile, x='Volatility', y='Ticker', palette='Reds_r')
plt.title("Top 5 Most Volatile Companies")
plt.xlabel("Standard Deviation of Closing Price")
plt.ylabel("Company (Ticker)")
plt.tight_layout()
plt.show()

"""# Top 5 Least Volatile Companies
This chart shows the five most stable stocks with the lowest price fluctuations. These companies are ideal for conservative investors seeking steady, lower-risk options.









"""

# Top 5 least volatile
bottom_5_volatile = volatility_df.sort_values(by='Volatility', ascending=True).head(5)

# Plot
plt.figure(figsize=(8, 5))
sns.barplot(data=bottom_5_volatile, x='Volatility', y='Ticker', palette='Greens')
plt.title(" Top 5 Least Volatile Companies")
plt.xlabel("Standard Deviation of Closing Price")
plt.ylabel("Company (Ticker)")
plt.tight_layout()
plt.show()

"""# Stock Price Distribution by Industry
This violin plot shows the spread and concentration of stock prices within each industry. It helps investors compare pricing trends and identify industries with high or low price variability.
"""

plt.figure(figsize=(12, 6))
sns.violinplot(data=df, x="Industry_Tag", y="Close", palette="muted")

plt.title("Stock Price Distribution by Industry")
plt.xlabel("Industry")
plt.ylabel("Closing Price in $")
plt.xticks(rotation=45)

plt.show()

"""# Correlation Heatmap of Stock Data
This heatmap displays how different financial features (like Open, Close, Volume) are correlated with each other. It helps investors understand which variables move together, supporting better portfolio diversification decisions.
"""

# Drop the 'Capital Gains' column
df = df.drop(columns=['Capital Gains'], errors='ignore')

# Generate the heatmap without the 'Capital Gains' column
plt.figure(figsize=(10, 6))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.5)

plt.title("Correlation Heatmap of Stock Data")
plt.show()

"""# Top 5 Dividend-Paying Companies
This bar chart displays the companies that have paid out the highest total dividends. It helps income-focused investors identify reliable stocks for steady passive income through regular dividend payouts.
"""

# Reset index to convert Series to DataFrame
top_dividend_companies_df = top_dividend_companies.reset_index()

# Create the barplot
plt.figure(figsize=(10, 6))
sns.barplot(data=top_dividend_companies_df, x="Dividends", y="Brand_Name", palette="viridis")

# Set title and labels
plt.title("Top 5 Dividend-Paying Companies", fontsize=14)
plt.xlabel("Total Dividends", fontsize=12)
plt.ylabel("Company", fontsize=12)

# Show values on bars
for index, value in enumerate(top_dividend_companies_df["Dividends"]):
    plt.text(value, index, f"{value:.2f}", va='center')

# Show the plot
plt.show()

"""# Marriott – Close Price vs 20-Day Moving Average
This line chart compares Marriott’s actual closing price with its 20-day moving average. It helps investors spot price trends and potential buy/sell signals by smoothing out short-term fluctuations.
"""

# Example: Use one top company for clarity (e.g., 'marriott' or any from your top 10)
company_name = 'marriott'
df_company = df[df['Brand_Name'] == company_name].copy()

# Calculate 20-day Moving Average
df_company['MA20'] = df_company['Close'].rolling(window=20).mean()

# Plot
plt.figure(figsize=(10, 5))
plt.plot(df_company['Date'], df_company['Close'], label='Close Price')
plt.plot(df_company['Date'], df_company['MA20'], label='20-Day Moving Average', linestyle='--')
plt.title(f" {company_name.title()} – Close Price vs 20-Day Moving Average")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Bubble Chart: Dividends by Country and Industry
This interactive bubble chart shows which country-industry combinations contribute the most to total dividends. Larger bubbles indicate higher payouts, helping investors spot high-income sectors across different regions.
"""

import plotly.express as px

# Prepare data
bubble_data = df.groupby(["Country", "Industry_Tag"])["Dividends"].sum().reset_index()
bubble_data = bubble_data[bubble_data["Dividends"] > 0]

# Plot
fig = px.scatter(
    bubble_data,
    x="Country",
    y="Industry_Tag",
    size="Dividends",
    color="Dividends",
    color_continuous_scale="Viridis",
    title="💬 Bubble Chart: Dividends by Country and Industry",
    hover_name="Country",
    size_max=40
)

fig.update_layout(height=600)
fig.show()

"""# Calculating Sharpe and Sortino Ratios"""

# Ensure returns are calculated
df['Date'] = pd.to_datetime(df['Date'], errors='coerce', utc=True)
df.sort_values(['Ticker', 'Date'], inplace=True)
df['Returns'] = df.groupby('Ticker')['Close'].pct_change()

# Group-level stats
ratios = []

tickers = df['Ticker'].unique()

risk_free_rate = 0.01 / 252  # Assume 1% annual, adjusted to daily

for ticker in tickers:
    company_df = df[df['Ticker'] == ticker].dropna(subset=['Returns'])
    daily_returns = company_df['Returns']

    # Sharpe Ratio = (mean - risk-free) / std dev
    avg_return = daily_returns.mean()
    std_dev = daily_returns.std()
    sharpe = (avg_return - risk_free_rate) / std_dev if std_dev != 0 else 0

    # Sortino Ratio = (mean - risk-free) / downside std dev
    downside_returns = daily_returns[daily_returns < 0]
    downside_std = downside_returns.std()
    sortino = (avg_return - risk_free_rate) / downside_std if downside_std != 0 else 0

    ratios.append({'Ticker': ticker, 'Sharpe': sharpe, 'Sortino': sortino})

# Create DataFrame
ratios_df = pd.DataFrame(ratios).dropna()

"""This interactive scatter plot compares companies based on their Sharpe and Sortino ratios. It helps investors visually identify stocks that offer strong returns for the level of risk taken, with top-right companies being the most efficient performers."""

import plotly.express as px

# Clean up NaNs and prepare text
ratios_df_clean = ratios_df.dropna().copy()
ratios_df_clean['text'] = 'Ticker: ' + ratios_df_clean['Ticker'] + \
                          '<br>Sharpe: ' + ratios_df_clean['Sharpe'].round(2).astype(str) + \
                          '<br>Sortino: ' + ratios_df_clean['Sortino'].round(2).astype(str)

# Plot
fig = px.scatter(
    ratios_df_clean,
    x='Sharpe',
    y='Sortino',
    color='Ticker',
    hover_name='Ticker',
    hover_data={'Sharpe': ':.2f', 'Sortino': ':.2f', 'Ticker': False},
    size_max=15,
    title='📍 Interactive Sharpe vs Sortino Ratio Scatter Plot',
    labels={'Sharpe': 'Sharpe Ratio', 'Sortino': 'Sortino Ratio'}
)

fig.update_traces(marker=dict(size=12, line=dict(width=1, color='DarkSlateGrey')))
fig.update_layout(width=900, height=600)
fig.show()

"""# Financial Feature Relationships by Industry Group
This pairplot compares key financial features—Open, Close, High, and Low prices—across the top 10 companies, grouped by industry. It helps investors spot patterns, correlations, and overlaps in price behavior within and across sectors.
"""

# Step 1: Focus on top 10 companies by frequency
top_10_companies = df['Brand_Name'].value_counts().head(10).index.tolist()
df_top10 = df[df['Brand_Name'].isin(top_10_companies)].copy()

# Step 2: Apply industry group mapping again (in case this cell runs separately)
industry_groups = {
    'technology': 'Technology & Media',
    'gaming': 'Technology & Media',
    'social media': 'Technology & Media',
    'entertainment': 'Technology & Media',
    'music': 'Technology & Media',
    'retail': 'Consumer & Retail',
    'apparel': 'Consumer & Retail',
    'food & beverage': 'Consumer & Retail',
    'luxury goods': 'Consumer & Retail',
    'footwear': 'Consumer & Retail',
    'fitness': 'Consumer & Retail',
    'finance': 'Finance & Services',
    'financial services': 'Finance & Services',
    'e-commerce': 'Finance & Services',
    'logistics': 'Finance & Services',
    'healthcare': 'Healthcare & Life',
    'food': 'Healthcare & Life',
    'hospitality': 'Healthcare & Life',
    'aviation': 'Healthcare & Life',
    'manufacturing': 'Industrial & Other',
    'automotive': 'Industrial & Other',
    'cryptocurrency': 'Industrial & Other',
    'consumer goods': 'Industrial & Other'
}

df_top10['Industry_Group'] = df_top10['Industry_Tag'].map(industry_groups)

# Step 3: Drop any unmapped industries
df_grouped = df_top10.dropna(subset=['Industry_Group'])

# Step 4: Select only key features
features = ["Close", "Open", "High", "Low"]
# Step 5: Plot
plot = sns.pairplot(
    df_grouped,
    vars=features,
    hue="Industry_Group",
    plot_kws={'alpha': 0.6, 's': 20}
)

# Adjust the space above the plot and add a clean title
plot.fig.subplots_adjust(top=0.95)
plot.fig.suptitle("💡 Financial Feature Relationships by Industry Group (Top 10 Companies)", fontsize=14)
plt.show()

"""This notebook explored the financial performance, risk, and dividend behavior of top companies across various industries and countries. Through visual and statistical analysis, we identified key investment insights such as the most volatile and stable stocks, high dividend payers, and companies offering strong risk-adjusted returns.

These findings provide a solid foundation for guiding investment decisions and building investor confidence. This analysis can further be extended with predictive models, portfolio optimization strategies, or integration into a larger financial advisory system.


"""